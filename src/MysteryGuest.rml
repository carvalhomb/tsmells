/**
 * This file is part of TSmells
 *
 * TSmells is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU General Public License as published by the 
 * Free Software Foundation; either version 2 of the License, or (at your 
 * option) any later version.
 *
 * TSmells is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with TSmells; if not, write to the Free Software Foundation, Inc., 
 * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA 
 *
 * Copyright 2007 Manuel Breugelmans <manuel.breugelmans@student.ua.ac.be>
 */

/**
 * Append test entities and mystery-blacklist.
 * Functions/methods in the blacklist will only be handled if their
 * declaration is present in the model. 
 *
 * TestEntities: + writeCppTestEntities.rml
 *               + writeJavaTestEntities.rml
 *
 **/

// fake it implementation
// PRINT "mine::tests::FileAccessTest.testSomething(),mine::tests::FileAccessTest::testSomething(),file, java::io::BufferedReader::readLine()", ENDL;
//        ^^ testcase.testcommand()                   ^^ entitity which invokes smelly entity      ^^ mystery-type  ^^ smelly entity 

/**
 * fetches the IDs of blacklisted methods
 * @col x: mystery type
 * @col y: methodname
 * @col z: methodid
 */
Blacklist(x,y,z) := MysteryBlacklist(x,y) & (Method(z,y) | Function(z,y));
BlackID(x) := EX(y, MysteryBlacklist(_,y) & (Method(x,y) | Function(x,y)));

//PRINT ["Blacklist"] Blacklist(x,y,z);
//PRINT ["TestCommand"] TestCommand(x,y);
//PRINT ["Stimulates"] Stimulates(x,y,z);

/**
 * holds all testcommands containing a direct mystery invoke
 * @col a: TestCommand ID
 * @col b: Blacklisted method ID
 */
MysteryInTc(a,b) := TestCommand(a,_) & Stimulates(_,a,b) & Blacklist(_,_,b);

//PRINT ["MysteryInTc"] MysteryInTc(x,y);
//PRINT "TC     ", TestCommand(x,y),  ENDL;
//PRINT "STIM     ", Stimulates(x,y,z), ENDL;
//PRINT "BLACK ", Blacklist(x,y,z),  ENDL;

// print results
FOR tc IN MysteryInTc(x,_) {
    FOR myst IN MysteryInTc(tc,x) {
        MethodName(mn) := Method(tc, mn); 
        MystType(mt) := Blacklist(mt,_,myst);
        MystEnt(mn) := Blacklist(_,mn,myst);
        FileName(x) := EX(y, InvokableEntityBelongsToFile(tc,y,_) & File(y,x));
        LineNr(x) := InvokableEntityBelongsToFile(tc, _, x);

        FOR meth IN MethodName(mn) { // singleton
        FOR type IN MystType(mt)   { // singleton
        FOR myst IN MystEnt(mn)    { // singleton
        FOR file IN FileName(x)    { // singleton
        FOR line IN LineNr(x)      { // singleton
            // print twice since smell in tc itself
            PRINT "MysteryGuest;", meth, ";", file, ";", line, ";",
                  meth, ";", file, ";", line, ";", type, ";", myst, ENDL;
        }}}}}
    }
}

/**
 * holds all methods with smelly invokes
 * @col a: TestCommand ID
 * @col b: Method ID which invokes the blacklisted
 * @col c: Blacklisted method ID
 **/
//MysteryInTH(a,b,c) := TestHelper(b,_) & PureInvokes(_,b,c) & BlackID(c) & TestCommand(a,_) & PureInvokes(_,a,b);
TransInvokes(x,y) := TC(PureInvokes(_,x,y));
MysteryInM(a,b,c) :=  (Method(b,_) | Function(b,_)) & PureInvokes(_,b,c) & BlackID(c) & TestCommand(a,_) & TransInvokes(a,b);

//PRINT TransInvokes(x,y);

// print result
FOR tc IN MysteryInM(x,_,_) {
    FOR th IN MysteryInM(tc,x,_) {
        FOR myst IN MysteryInM(tc,th,x) {
            CommandName(mn) := Method(tc, mn);
            MethodName(hn) := Method(th, hn);
            MystType(mt) := Blacklist(mt,_,myst); 
            MystEnt(mn) := Blacklist(_,mn,myst);
            IF (#(MethodName(hn)) = 0) { 
                // function, not a method
                MethodName(hn) := Function(th, hn);
            }
            FileName(x) := EX(y, InvokableEntityBelongsToFile(tc,y,_) & File(y,x));
            LineNr(x) := InvokableEntityBelongsToFile(tc, _, x);
            MFileName(x) := EX(y, InvokableEntityBelongsToFile(th,y,_) & File(y,x));
            MLineNr(x) := InvokableEntityBelongsToFile(th, _, x);

            FOR cmd  IN CommandName(mn) { // singleton
            FOR meth IN MethodName(hn)  { // singleton
            FOR type IN MystType(mt)    { // singleton
            FOR myst IN MystEnt(mn)     { // singleton
            FOR file IN FileName(x)     { // singleton
            FOR line IN LineNr(x)       { // singleton
            FOR mfil IN MFileName(x)    { // singleton
            FOR mlin IN MLineNr(x)      { // singleton
                PRINT "MysteryGuest;", cmd, ";", file, ";", line, ";",
                      meth, ";", mfil, ";", mlin, ";", type, ";", myst, ENDL;
            }}}}}}}}
        }
    }
}
